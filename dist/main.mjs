import{Y as YAML,g as glob,p as parse,c as coreExports}from"./deps.mjs";import fs from"node:fs/promises";import path from"node:path";import"os";import"fs";import"path";import"http";import"https";import"net";import"tls";import"events";import"assert";import"util";import"stream";import"buffer";import"querystring";import"stream/web";import"node:stream";import"node:util";import"node:events";import"worker_threads";import"perf_hooks";import"util/types";import"async_hooks";import"console";import"url";import"zlib";import"string_decoder";import"diagnostics_channel";import"fs/promises";const env=process.env,GITHUB_TOKEN=env.GITHUB_TOKEN,[GITHUB_OWNER,GITHUB_REPO]=env.GITHUB_REPOSITORY?.split("/")??[];const githubRepo=new class GithubRepo{constructor(owner,repo,token){this.owner=owner,this.repo=repo,this.token=token,this.#headers=new Headers({accept:"application/vnd.github.v3+json"}),token&&this.#headers.append("authorization","token "+token)}#headers;async listGitHubTags(tagPrefix=""){const{owner:owner,repo:repo}=this,resp=await fetch(`https://api.github.com/repos/${owner}/${repo}/git/matching-refs/tags/${tagPrefix}`,{headers:this.#headers});if(resp.ok){return(await resp.json()).map((item=>item.ref.slice(10)))}throw new Error(resp.statusText)}}(GITHUB_OWNER,GITHUB_REPO,GITHUB_TOKEN);async function findPnpmWorkspacePkgs(workspaceRoot){const[rootPkg,packagesGlob]=await Promise.all([readPackageJson(workspaceRoot),getPnpmWorkspaceDefine(path.resolve(workspaceRoot,"pnpm-workspace.yaml"))]);rootPkg.packageRoot=workspaceRoot;for(let i=0;i<packagesGlob.length;i++)packagesGlob[i].endsWith("/")||(packagesGlob[i]=packagesGlob[i]+"/package.json");const packageFile=await glob(packagesGlob,{root:workspaceRoot,cwd:workspaceRoot,nodir:!0,absolute:!0}),{success:success,fail:fail}=await function allSettled(list){return Promise.allSettled(list).then((res=>{const success=[],fail=[];for(const item of res)"fulfilled"===item.status?success.push(item.value):fail.push(item.reason);return{success:success,fail:fail}}))}(packageFile.map((async filename=>{const dir=path.resolve(filename,".."),text=await fs.readFile(filename,"utf-8");return{...JSON.parse(text),packageRoot:dir}})));return{success:success,fail:fail,rootPkg:rootPkg}}async function readPackageJson(pkgDir){const filename=path.resolve(pkgDir,"package.json"),text=await fs.readFile(filename,"utf-8");return JSON.parse(text)}async function getPnpmWorkspaceDefine(file){const text=await fs.readFile(file,"utf-8");try{const obj=parse(text);return obj.packages instanceof Array?obj.packages:[]}catch(error){return[]}}function pasePkgTags(pkg,prefix,namePrefix){const dir=pkg.packageRoot;if(namePrefix){let name=pkg.name;if("string"!=typeof name&&(name=dir.slice(dir.lastIndexOf(path.sep))),name.startsWith("@")&&(name=name.slice(name.indexOf("/")+1)),""===name)throw new Error(dir+": 包名无效");prefix=name+"/"+prefix}if(pkg.version)return prefix+pkg.version;throw new Error("version 字段不存在")}await async function main(){const file=coreExports.getInput("file"),preset=coreExports.getInput("preset");let versions;if(preset)versions=await function getPreset(preset){if("pnpm-workspace"===preset)return async function getWorkspaceTags(workspaceRoot,options={}){const{includeRoot:includeRoot,subPrefix:subPrefix="",rooNamePrefix:rooNamePrefix=!1,rootPrefix:rootPrefix=(rooNamePrefix?"":"v")}=options;let pkgInfoList;const{success:success,fail:fail,rootPkg:rootPkg}=await findPnpmWorkspacePkgs(workspaceRoot);if(fail.length&&console.log(`查找失败: ${fail.join(", ")}`),pkgInfoList=success,0===pkgInfoList.length)return console.log("没有搜索到包, 跳过"),[];const tags=[];for(const pkg of pkgInfoList)tags.push(pasePkgTags(pkg,subPrefix,!0));return includeRoot&&tags.push(pasePkgTags(rootPkg,rootPrefix,rooNamePrefix)),tags}(coreExports.getInput("file"),{subPrefix:coreExports.getInput("prefix")});throw new Error("不支持预设："+preset)}(preset);else{const field=coreExports.getInput("field"),prefix=coreExports.getInput("prefix");versions=await async function getVersion(jsonpath,field,prefix){jsonpath=path.resolve(jsonpath);const json=await async function readfile(filename){const text=await fs.readFile(filename,"utf-8"),{ext:ext}=path.parse(filename);switch(ext){case".json":return JSON.parse(text);case".yaml":case".yml":return YAML.parse(text);default:throw new Error("无法解析扩展名："+filename)}}(jsonpath).catch((e=>{throw new Error("json 文件读取失败："+jsonpath,{cause:e})})),version=json?.[field];if("string"==typeof version)return[version];if(version instanceof Array)return prefix?version.map((val=>prefix+val)):version;throw new Error(`JSON '${field}' 字段(${typeof version}) 不存在或格式错误`)}(file,field,prefix)}versions=await async function filterNoExistTags(tags){if(0===tags.length)return[];const allTags=new Set(await githubRepo.listGitHubTags());return tags.filter((tag=>!allTags.has(tag)))}(versions),versions.length?(coreExports.setOutput("tags",JSON.stringify(versions)),console.log("Tags: "+versions.join(", "))):console.log("No tags")}();